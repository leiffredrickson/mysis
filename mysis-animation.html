<!DOCTYPE html>
<html>

<head>
  <meta charset=utf-8 />
  <title>Shrimp animation</title>
  <meta name='viewport' content='initial-scale=1,maximum-scale=1,user-scalable=no' />

  <!--The following are Mapbox.js libraries, which are extensions of Leaflet.js libraries.
Mapbox now has a new Javascript library, Mapbox GL JS, that renders maps using vector tils, Javascript and Web GL.
But Mapbox there are not equivalent examples for animating lines in Mapbox GL JS.
The Mapbox examples drawn on are:
1. "Animating Flight Paths," https://www.mapbox.com/mapbox.js/example/v1.0.0/animating-flight-paths/
2. "Filtering Markers," https://www.mapbox.com/mapbox.js/example/v1.0.0/filtering-markers/ -->
  <script src='https://api.mapbox.com/mapbox.js/v3.1.1/mapbox.js'></script>
  <link href='https://api.mapbox.com/mapbox.js/v3.1.1/mapbox.css' rel='stylesheet' />

  <style>
  /*Style for the body using internal CSS*/

    body {
      margin: 0;
      padding: 0;
    }
    /*Style for the map using CSS id attribute ("map" is identified as a div element below)*/

    #map {
      position: absolute;
      top: 0;
      bottom: 0px;
      width: 100%;
    }
    /*Create CSS color "variables" that can be used in different places.*/

     :root {
      --kokanee: rgba(247, 90, 152, 0.99);
      --lake: rgb(35, 110, 158);
      --whitebass-steelhead: rgb(219, 217, 0);
      --unintentional: rgb(0, 133, 29);
      --rainbow: rgb(255, 107, 0);
      --trout: rgb(36, 45, 251);
      --kokanee-trout: rgb(124, 37, 210);
    }
    /*Style for navigation menu using CSS class attribute (nav element created below and given this CSS class)*/

    .menu-ui {
      background: rgb(240, 237, 228);
      position: absolute;
      top: 10px;
      right: 10px;
      z-index: 1;
      border-radius: 3px;
      width: 180px;
      border: 2px solid rgba(0, 0, 0, 0.4);
      opacity: 0.9;
    }

    .menu-ui a {
      font-family: sans-serif;
      font-size: 13px;
      font-weight: bold;
      /*text-shadow: -1px 0 white, 0 1px white, 1px 0 white, 0 -1px white;*/
      color: #000000;
      display: block;
      margin: 0;
      padding: 0;
      padding: 10px;
      text-decoration: none;
      border-bottom: 2px solid rgba(0, 0, 0, 0.25);
      text-align: center;
      opacity: 0.9;
    }

    .menu-ui a:first-child {
      border-radius: 3px 3px 0 0;
    }

    .menu-ui a:last-child {
      border: none;
      border-radius: 0 0 3px 3px;
    }

    .menu-ui a:hover {
      font-weight: bolder;
      font-size: 14px;
      opacity: 1.0;
    }

    .menu-ui a.active,
    .menu-ui a.active:hover {
      font-weight: bold;
      color: #040404;
      font-size: 14px;
      opacity: 1.0;
    }
  }

  .menu-ui.active {
    opacity: 1.0;
  }

  #filter-kokanee {
    background-color: var(--kokanee);
  }

  #filter-lake {
    background-color: var(--lake)
  }

  #filter-whitebasssteelhead {
    background-color: var(--whitebass-steelhead)
  }

  #filter-unintentional {
    background-color: var(--unintentional)
  }

  #filter-rainbow {
    background-color: var(--rainbow)
  }

  #filter-trout {
    background-color: var(--trout)
  }

  #filter-kokaneetrout {
    background-color: var(--kokanee-trout)
  }
  /* The path-start class is added to each line to manage its animation - this interpolates
between the starting and ending values for the stroke-dashoffset css property.
webkit is Chrome and Safari browsers; moz is Mozilla; o is Opera; nothing is Explorer/Edge */
  .path-start {
    -webkit-transition: stroke-dashoffset 5s ease-in;
    -moz-transition: stroke-dashoffset 5s ease-in;
    -o-transition: stroke-dashoffset 5s ease-in;
    transition: stroke-dashoffset 2s ease-in;
  }
  </style>
</head>

<body>
  <!-- We use arc.js to make our paths curved. -->
  <script src='https://api.mapbox.com/mapbox.js/plugins/arc.js/v0.1.0/arc.js'></script>

  <!-- This is the data file.
Had to add this to the first line of the original file: data =
so the first line of the file looks like this: data = {-->
  <script src='mysis-data-all-na.geojson'></script>

  <!-- Create navigation bar with menu style above -->
  <nav id='menu-ui' class='menu-ui'>
    <a href='#' id='filter-all'>Start Animation</a>
    <a href='#' id="timer_container">Year: 1945</a>
    <a href='#' id='filter-rainbow'>Rainbow Trout</a>
    <a href='#' id='filter-lake'>Lake Trout</a>
    <a href='#' id='filter-trout'>Trout (General)</a>
    <a href='#' id='filter-kokaneetrout'>Kokanee + Trout</a>
    <a href='#' id='filter-kokanee'>Kokanee Salmon</a>
    <a href='#' id='filter-whitebasssteelhead'>White Bass + Steelhead</a>
    <a href='#' id='filter-unintentional'>Unintentional</a>
    <a href='#' id='filter-all-static'>All Fish</a>
  </nav>

  <!-- Create navigation bar with map style above.
Style "dark" renders text/foreground light on dark background (default is vice versa) -->
  <div id='map' class='dark' style="height:75em" )></div>

  <script>
    // Create the pairs array (creates an empty array to be filled later)
    var pairs = [];

    /* data comes from the mysis_northamerica.geojson file sourced above
    data.features.forEach loops through all of the objects in the features object only.
    Apparently "data" automatically selects the geojson file (unclear to me).
    So this says: select geojson, select features array within geojson.
    Then run the "forEach" function, which runs a "callback function" for each element in array.\
    (A callback function is a function passed into another function as an argument;
    it does not need to be named callbackfn or anything at all).
    The forEach function is often used instead of a "for loop."
    The callback function used here uses curVal as argument.
    So for each element of the "features" array (the array of lakes basically),
    the function will perform everything in the curly brackets.
    It takes the current value of each element in the array of lakes.
    Then its selects the "geometry" object and the "coordinates" variable
    within "geometry," and then the first and second values for "coordinates,"
    which it assignes to the variables destinationLon and destinationLat respectively.
    And so on for the values assigned to the source lat/lon variables.
    Every time these four sets of variables are assigned values for a given array element,
    those variable-value pairs are "pushed" to the pairs variable created earlier.
    Finally, it adds the variables amount, year, fish and assigns them values from array.
    So we end up with a pairs variable that contains three arrays.
    The third array includes an object that has three variables. */
    data.features.forEach(function callbackfn(curVal) {
      // Grab the origin values and set to a variable
      var destinationLon = curVal.geometry.coordinates[0];
      var destinationLat = curVal.geometry.coordinates[1];

      // Grab the source lat/long and store as variable
      var sourceLon = curVal.properties.long_source;
      var sourceLat = curVal.properties.lat_source;

      /* this creates an object containing the origin and destination lat/longs,
      and then puts that into the points array created earlier.*/
      pairs.push([
        [
          sourceLat,
          sourceLon
        ],
        [
          destinationLat,
          destinationLon
        ],
        [{
          'amount': curVal.properties.amount,
          'year': curVal.properties.year,
          'fish': curVal.properties.fish,
        }]
      ]);

    });

    /*To use any of Mapboxâ€™s tools, APIs, or SDKs, you need a Mapbox access token.*/
    L.mapbox.accessToken = 'pk.eyJ1Ijoic2Nob2xhcnNsYWIiLCJhIjoiY2oxdzlqNDh1MDAwMTMzcW96MGxtajZxNSJ9.8I1zZymMKofR_FbOiazznw';

    /* L.map function creates a map on a page and manipulates it. "l." is a prefix for Leaflet methods. Mapbox created Leaflet.
    L.mapbox.map extends L.map to mapbox API.
    Requires an argument (aka parameter) that is an id of an element.
    In this case, it is "map" which is the id of the div element above.
    Can also take other arguments/options.
    See: https://www.mapbox.com/mapbox.js/api/v3.1.1/l-mapbox-map/
    In this case, function includes argument for mapbox map id "mapbox.light."
    For other mapbox map IDs, see https://www.mapbox.com/api-documentation/#maps.
    "setView" is a method for setting map view (center and zoom).
    "setView" method is here https://www.mapbox.com/mapbox.js/api/v3.1.1/all/#map-set-methods.*/
    var map = L.mapbox.map('map', 'mapbox.light')
      .setView([43.456388, -101.905068], 5);

    /*This creates attribution text at bottom of map.
    Created automoatically and attribution data pulled automatically.
    Can be disabled or added to.*/
    var credits = L.control.attribution({}).addTo(map);

    /* From mapbox: "This is an advanced example that is compatible withmodern browsers and IE9+ -
    the trick it uses is animation of SVG properties,
    which makes it relatively efficient for the effect produced.
    That said, the same trick means that theanimation is non-geographical -
    lines interpolate in the same amount of time regardless of trip length."*/

    /* In original code, drag and zoom are disabled,
    because animation effect does not work well zoomed (dashes instead of moving lines).
    But I want people to be able to zoom after animation, so re-enabled these.
    map.dragging.disable();
    map.touchZoom.disable();
    map.scrollWheelZoom.disable();
    map.doubleClickZoom.disable();*/
    if (map.tap) map.tap.disable();

    /* Transform the short [lat,lng] format in our data into the {x, y} expected by arc.js.
    What this does is create a function "obj" which takes an argument (aka parameter)
    and extracts the first [0] and second [1] values of the array of that parameter.
    Those values are placed where ll[0] and ll[1] would be,
    so the end product is {y: some latitude, x: some longitude}.
    This is the format need to by arc.js to create an arc --
    i.e., two sets of longitude and latitude numbers in curly brackets.*/
    function obj(ll) {
      return {
        y: ll[0],
        x: ll[1]
      };
    }

    /* Rather than additing direclty to map, as in original example, we make a feature layer.
    That way we can have different layers for different fish, etc.
    featureLayer is a method that allows use of geojson data.*/
    var featureLayer = L.mapbox.featureLayer().addTo(map);

    /*In the original, this was a "for loop," not a function.
    But since need to repeat the loop with different layers,
    made this into a function that can pass data on specific fish.
    Whatever is put in the function brackets will be placed where "fishes" is in
    the code contained in the function. So later, we call the function for "pairs,"
    by writing "showfish(pairs). When that is run, the "for loop" will run until
    i < pairs.length, the amount variable will be equal to "pairs[i][2][0]" and so on.
    If we were only working with one set of lat/long variables (as in the original example),
    we wouldn't need a function and would just input pairs.length, etc. in code block below.*/
    function showfish(fishes) {
      /*This is a "for loop" that executes code blocks over and over.
      This says that for the given data/array (which is passed to the loop via the
      function argument above), start with the first variable in the array
      (i.e., set the counter variable, i, to zero) and run the loop.
      After the loop, increment the counter variable value by one.
      If the second statement, i<fish.length, is ever untrue, then the loop stops.
      The .length property is the number of variables in the array.*/
      for (var i = 0; i < fishes.length; i++) {
        /*Since our data is in slightly different form than original example,
        we need to extract it and put it into form that can be used to make arcs,
        and to visualize those arcs in different ways.
        For each of the below, we create and name a variable.
        The variable's value changing with the argument (i.e., data set) passed in the showfish() function,
        and the specific objects and values referenced.
        For example, var fish = fishes[1][2][0].fish does the following:
        The "for loop" cycles through each i value starting with 0.
        So for the given data set, it picks out the first object (the zero position).
        In this case, that means it is picking out one of the instances of a lake introduciton.
        Then it picks out the third object (position two) located in the first object (the lake).
        In the geojson data set, the first object is "type" with value "feature."
        The second object is "geometry," which includes other objects and values.
        The third object is "properties," with contains an array (an object)
        with many variables and values. So the [2] after [i] selects the "properties" object.
        Then the [0] selects the first (and in this case, only) object within the "properties"
        object, which is an array. Within that array, it selects a variable, "fish" and returns
        the value of that variable.
        This is a loop, so it loops through and does this for all the objects in the data set.*/
        var amount = fishes[i][2][0].amount;
        var year = fishes[i][2][0].year;
        var fish = fishes[i][2][0].fish;
        var secs = year - 1945;

        var colorChange = '';
        if (fish === "kokanee") {
          colorChange = 'var(--kokanee)';
        } else if (fish === "lake") {
          colorChange = 'var(--lake)';
        } else if (fish === "whitebass-steelhead") {
          colorChange = 'var(--whitebass-steelhead)';
        } else if (fish === "unintentional") {
          colorChange = 'var(--unintentional)';
        } else if (fish === "rainbow") {
          colorChange = 'var(--rainbow)';
        } else if (fish === "trout") {
          colorChange = 'var(--trout)';
        } else if (fish === "kokanee-trout") {
          colorChange = 'var(--kokanee-trout)';
        } else {
          colorChange = "";
        }

        var weightChange = 3

        /* Transform each pair of coordinates into a great circle using Arc.js.
        So below, we are taking the data set passed from the showfish() function.
        No variable named "fishes" is actually passed in this code, but "pairs"
        and perhaps other are passed below. For the argument passed, we grab each
        of the main objects/arrays (lakes) in it iteratively (with [i]),
        then grab the first and second arrays within those main objects.
        The obj() function has been defined above as obj(ll) { return { y: ll[0], x: ll[1] }; }
        So for each of the two arrays grabbed from the lake arrays,
        it takes the first and second values in the array. Which are lat and long coordinates.
        It puts these in the form acceptable to arc.js, after they are flipped (see below) */
        var generator = new arc.GreatCircle(
          obj(fishes[i][0]),
          obj(fishes[i][1]));
        var line = generator.Arc(100, {
          offset: 10
        });
        /* Leaflet expects [lat,lng] arrays, but a lot of software does the opposite,
        including arc.js, so we flip here. */
        var newLine = L.polyline(line.geometries[0].coords.map(function(c) {
            return c.reverse();
          }), {
            color: colorChange,
            weight: weightChange,
            opacity: 0.4
          })
          .addTo(featureLayer);
        var totalLength = newLine._path.getTotalLength();
        newLine._path.classList.add('path-start');
        // This pair of CSS properties hides the line initially
        // See http://css-tricks.com/svg-line-animation-works/
        // for details on this trick.
        newLine._path.style.strokeDashoffset = totalLength;
        newLine._path.style.strokeDasharray = totalLength;
        // Offset the timeout here: setTimeout makes a function
        // run after a certain number of milliseconds - in this
        // case we want each flight path to be staggered a bit.
        setTimeout((function(path) {
          return function() {
            // setting the strokeDashoffset to 0 triggers
            // the animation.
            path.style.strokeDashoffset = 0;
          };
        })(newLine._path), secs * 1000);
      }
    } /* This is the end of the showfish(fishes) function*/

    function staticfish(fishes) {

      for (var i = 0; i < fishes.length; i++) {
        var amount = fishes[i][2][0].amount;
        var year = fishes[i][2][0].year;
        var fish = fishes[i][2][0].fish;
        var secs = year - 1948;

        var colorChange = '';
        if (fish === "kokanee") {
          colorChange = 'var(--kokanee)';
        } else if (fish === "lake") {
          colorChange = 'var(--lake)';
        } else if (fish === "whitebass-steelhead") {
          colorChange = 'var(--whitebass-steelhead)';
        } else if (fish === "unintentional") {
          colorChange = 'var(--unintentional)';
        } else if (fish === "rainbow") {
          colorChange = 'var(--rainbow)';
        } else if (fish === "trout") {
          colorChange = 'var(--trout)';
        } else if (fish === "kokanee-trout") {
          colorChange = 'var(--kokanee-trout)';
        } else {
          colorChange = "";
        }

        var weightChange = 3

        var generator = new arc.GreatCircle(
          obj(fishes[i][0]),
          obj(fishes[i][1]));
        var line = generator.Arc(100, {
          offset: 10
        });
        var newLine = L.polyline(line.geometries[0].coords.map(function(c) {
            return c.reverse();
          }), {
            color: colorChange,
            weight: weightChange,
            opacity: 0.4
          })
          .addTo(featureLayer);
      }
    }

    var all = document.getElementById('filter-all'),
      allstatic = document.getElementById('filter-all-static'),
      kokaneefilter = document.getElementById('filter-kokanee'),
      rainbowfilter = document.getElementById('filter-rainbow'),
      lakefilter = document.getElementById('filter-lake'),
      troutfilter = document.getElementById('filter-trout'),
      kokaneetroutfilter = document.getElementById('filter-kokaneetrout'),
      whitebasssteelheadfilter = document.getElementById('filter-whitebasssteelhead'),
      unintentionalfilter = document.getElementById('filter-unintentional');


      // Date counter. Starts at 1945 and counts up one every second, until  1990.
        var counter = 1945
        var timer;
          function countUP () {

            if (counter < 1990) {
            counter = counter + 1;
            //increment the counter by 1, display the new value in the div
            document.getElementById("timer_container").innerHTML = 'Year: ' + counter;
            }
            //if counter less than 1990, countup, otherwise
            else {}
          }

    all.onclick = function() {
      // remove all points and lines
      featureLayer.clearLayers();

      // Changes the a tag with the following id class to nothing
      allstatic.className = '';
      kokaneefilter.className = '';
      rainbowfilter.className = '';
      lakefilter.className = '';
      troutfilter.className = '';
      kokaneetroutfilter.className = '';
      whitebasssteelheadfilter.className = '';
      unintentionalfilter.className = '';
      // Make only "this" class ("all") active
      this.className = 'active';

      showfish(pairs);

      timer=setInterval("countUP()", 1000 );

    };

    allstatic.onclick = function() {

      featureLayer.clearLayers();

      all.className = '';
      kokaneefilter.className = '';
      rainbowfilter.className = '';
      lakefilter.className = '';
      troutfilter.className = '';
      kokaneetroutfilter.className = '';
      whitebasssteelheadfilter.className = '';
      unintentionalfilter.className = '';
      this.className = 'active';

      staticfish(pairs);

      document.getElementById("timer_container").innerHTML = 'Year: 1949-1990';
    };

    kokaneefilter.onclick = function(e) {
      featureLayer.clearLayers();


      all.className = '';
      allstatic.className = '';
      rainbowfilter.className = '';
      lakefilter.className = '';
      troutfilter.className = '';
      kokaneetroutfilter.className = '';
      whitebasssteelheadfilter.className = '';
      unintentionalfilter.className = '';
      this.className = 'active';
      // find only the kokanee
      var kokaneepairs = pairs.filter(function(obj) {
        return obj[2][0].fish === 'kokanee'
      });
      staticfish(kokaneepairs);
    };

    rainbowfilter.onclick = function(e) {
      featureLayer.clearLayers();

      all.className = '';
      allstatic.className = '';
      kokaneefilter.className = '';
      lakefilter.className = '';
      troutfilter.className = '';
      kokaneetroutfilter.className = '';
      whitebasssteelheadfilter.className = '';
      unintentionalfilter.className = '';
      this.className = 'active';
      var rainbowpairs = pairs.filter(function(obj) {
        return obj[2][0].fish === 'rainbow'
      });
      staticfish(rainbowpairs);
    };

    lakefilter.onclick = function(e) {
      featureLayer.clearLayers();

      all.className = '';
      allstatic.className = '';
      kokaneefilter.className = '';
      rainbowfilter.className = '';
      troutfilter.className = '';
      kokaneetroutfilter.className = '';
      whitebasssteelheadfilter.className = '';
      unintentionalfilter.className = '';
      this.className = 'active';
      var lakepairs = pairs.filter(function(obj) {
        return obj[2][0].fish === 'lake'
      });
      staticfish(lakepairs);
    };

    troutfilter.onclick = function(e) {
      featureLayer.clearLayers();

      all.className = '';
      allstatic.className = '';
      kokaneefilter.className = '';
      rainbowfilter.className = '';
      lakefilter.className = '';
      kokaneetroutfilter.className = '';
      whitebasssteelheadfilter.className = '';
      unintentionalfilter.className = '';
      this.className = 'active';
      var troutpairs = pairs.filter(function(obj) {
        return obj[2][0].fish === 'trout'
      });
      staticfish(troutpairs);
    };

    kokaneetroutfilter.onclick = function(e) {
      featureLayer.clearLayers();

      all.className = '';
      allstatic.className = '';
      kokaneefilter.className = '';
      rainbowfilter.className = '';
      lakefilter.className = '';
      troutfilter.className = '';
      whitebasssteelheadfilter.className = '';
      unintentionalfilter.className = '';
      this.className = 'active';
      var kokaneetroutpairs = pairs.filter(function(obj) {
        return obj[2][0].fish === 'kokanee-trout'
      });
      staticfish(kokaneetroutpairs);
    };

    whitebasssteelheadfilter.onclick = function(e) {
      featureLayer.clearLayers();

      all.className = '';
      allstatic.className = '';
      kokaneefilter.className = '';
      rainbowfilter.className = '';
      lakefilter.className = '';
      troutfilter.className = '';
      kokaneetroutfilter.className = '';
      unintentionalfilter.className = '';
      this.className = 'active';
      var whitebasssteelheadpairs = pairs.filter(function(obj) {
        return obj[2][0].fish === 'whitebass-steelhead'
      });
      staticfish(whitebasssteelheadpairs);
    };

    unintentionalfilter.onclick = function(e) {
      featureLayer.clearLayers();

      all.className = '';
      allstatic.className = '';
      kokaneefilter.className = '';
      rainbowfilter.className = '';
      lakefilter.className = '';
      troutfilter.className = '';
      kokaneetroutfilter.className = '';
      whitebasssteelheadfilter.className = '';
      this.className = 'active';
      var unintentionalpairs = pairs.filter(function(obj) {
        return obj[2][0].fish === 'unintentional'
      });
      staticfish(unintentionalpairs);
    };
  </script>


</body>

</html>
